%{

#include <iostream>
#include <string>
#include <vector>
#include <map>
#include "ast.hpp"

using namespace std;

extern int yylex();

void yyerror(const std::string &msg) {
	cerr << msg << std::endl;
	exit(1);
}

extern llvm::Module* TheModule;
extern llvm::LLVMContext TheContext;
extern IRBuilder<> Builder;
Function *MainFja;
Function *PrintfFja;
Value* Str;


%}

%union {
	int i;
	double d;
	string *s;
	ExpressionNode *e;
	vector<ExpressionNode*> *ve;
	vector<string> *vs;
	FunctionPrototypeNode *p;
}

%token token_int token_double token_id token_assign token_return token_function
%token token_for token_in token_if token_else token_print token_main
%token token_eq token_leq token_geq token_not token_neq

%type <i> token_int
%type <d> token_double
%type <s> token_id
%type <e> EXPRESSION EXPRESSIONP STATEMENT
%type <vs> LIST_PARAMS LIST_PARAMSP
%type <ve> LIST_ARGS LIST_ARGSP STATEMENTSP


%right token_assign
%right token_not

%left ':'
%left token_eq token_neq
%left '<' '>' token_leq token_geq
%left '+' '-'
%left '*' '/'

%%

STATEMENTSP
    : STATEMENTSP STATEMENT {
		$$ = $1;
		$$->push_back($2);
	}
    | STATEMENT {
		$$ = new vector<ExpressionNode*>;
		$$->push_back($1);
	}
    ;

STATEMENT
    : token_id token_assign EXPRESSION {
		$$ = new AssignmentNode(*$1, $3);
		delete $1;
	}
    | token_id '[' EXPRESSION ']' token_assign EXPRESSION {

	}
    | token_id token_assign token_function '(' LIST_PARAMS ')' '{' STATEMENTSP '}' {
		FunctionNode f(FunctionPrototypeNode(*$1, *$5), new BlockNode(*$8));
		delete $1;
		delete $5;
		delete $8;
		f.codegen();
		$$ = new EmptyNode();
	}
	| token_main token_assign token_function '(' LIST_PARAMS ')' '{' STATEMENTSP '}' {
		vector<Type*> v(0);
	    FunctionType* FT2 = FunctionType::get(Type::getInt32Ty(TheContext), v, false);
	    MainFja = Function::Create(FT2, Function::ExternalLinkage, "main", TheModule);
	    BasicBlock *BB = BasicBlock::Create(TheContext, "entry", MainFja);
	    Builder.SetInsertPoint(BB);

		Str = Builder.CreateGlobalStringPtr("%d\n");

		$$ = new BlockNode(*$8);
		$$->codegen();
		delete $8;

		Builder.CreateRet(ConstantInt::get(TheContext, APInt(32, 0)));
	    verifyFunction(*MainFja);
	}
    | token_if '(' EXPRESSION ')' '{' STATEMENTSP '}' {
		$$ = new IfElseNode($3, new BlockNode(*$6), new EmptyNode());
	}
    | token_if '(' EXPRESSION ')' '{' STATEMENTSP '}' token_else '{' STATEMENTSP '}' {
		$$ = new IfElseNode($3, new BlockNode(*$6), new BlockNode(*$10));
		delete $6;
		delete $10;
	}
    | token_for '(' token_id  token_in EXPRESSION ':' EXPRESSION ')' '{' STATEMENTSP '}' {
		$$ = new ForLoopNode(*$3, $5, $7, new BlockNode(*$10));
		delete $3;
		delete $10;
	}
	| token_return '(' EXPRESSIONP ')' {
		$$ = new ReturnNode($3);
	}
	| token_print '(' EXPRESSIONP ')' {
		$$ = new PrintNode($3);
	}
    ;

EXPRESSIONP
    : EXPRESSION {
		$$ = $1;
	}
    | {
		$$ = NULL;
	}
    ;

LIST_PARAMS
    : LIST_PARAMSP {
		$$ = $1;
	}
    | {
		$$ = new vector<string>;
	}
    ;

LIST_PARAMSP
    : LIST_PARAMSP ',' token_id {
		$$ = $1;
		$$->push_back(*$3);
		delete $3;
	}
    | token_id {
		$$ = new vector<string>;
		$$->push_back(*$1);
		delete $1;
	}
    ;

/* LIST_DEC_ARGS_OR_ARGS
    : LIST_ARGS {
		$$ = $1;
	}
    | LIST_DEC_ARGS {

	}
    ; */

/* LIST_DEC_ARGS
    : LIST_DEC_ARGS ',' token_id token_assign EXPRESSION {

	}
    | token_id token_assign EXPRESSION {

	}
    ; */

LIST_ARGS
    : LIST_ARGSP {
		$$ = $1;
	}
    | {
		$$ = new vector<ExpressionNode*>;
	}
    ;

LIST_ARGSP
    : LIST_ARGSP ',' EXPRESSION {
		$$ = $1;
		$$->push_back($3);
	}
    | EXPRESSION {
		$$ = new vector<ExpressionNode*>;
		$$->push_back($1);
	}
    ;

EXPRESSION
    : EXPRESSION '+' EXPRESSION {
		$$ = new BinaryOperatorNode(bin_op::plus, $1, $3);
	}
    | EXPRESSION '-' EXPRESSION {
		$$ = new BinaryOperatorNode(bin_op::minus, $1, $3);
	}
    | EXPRESSION '*' EXPRESSION {
		$$ = new BinaryOperatorNode(bin_op::mul, $1, $3);
	}
    | EXPRESSION '/' EXPRESSION {
		$$ = new BinaryOperatorNode(bin_op::di, $1, $3);
	}
    | EXPRESSION '>' EXPRESSION {
		$$ = new BinaryOperatorNode(bin_op::gt, $1, $3);
	}
    | EXPRESSION '<' EXPRESSION {
		$$ = new BinaryOperatorNode(bin_op::lt, $1, $3);
	}
    | EXPRESSION token_eq EXPRESSION {
		$$ = new BinaryOperatorNode(bin_op::eq, $1, $3);
	}
    | EXPRESSION token_leq EXPRESSION {
		$$ = new BinaryOperatorNode(bin_op::leq, $1, $3);
	}
    | EXPRESSION token_geq EXPRESSION {
		$$ = new BinaryOperatorNode(bin_op::geq, $1, $3);
	}
    | EXPRESSION token_neq EXPRESSION {
		$$ = new BinaryOperatorNode(bin_op::neq, $1, $3);
	}
    | token_not EXPRESSION {

	}
    | '(' EXPRESSION ')' {
		$$ = $2;
	}
    | token_id {
		$$ = new VariableNode(*$1);
		delete $1;
	}
    | token_id '[' EXPRESSION ']' {

	}
    | token_id '(' LIST_ARGS ')' {
		$$ = new FunctionCallNode(*$1, *$3);
		delete $1;
		delete $3;
	}
    | token_int {
		$$ = new ConstantNode($1);
	}
    | token_double {
	}
    ;

%%


int main() {
	InitializeModuleAndPassManager();
	cerr << "1" << endl;
	FunctionType *FT1 = FunctionType::get(IntegerType::getInt32Ty(TheContext), PointerType::get(Type::getInt8Ty(TheContext), 0), true);
	PrintfFja = Function::Create(FT1, Function::ExternalLinkage, "printf", TheModule);
	cerr << "2" << endl;
	//Str = Builder.CreateGlobalStringPtr("%d\n");
	cerr << "3" << endl;
	yyparse();
	cerr << "4" << endl;
	TheModule->print(llvm::outs(), nullptr);
	cerr << "5" << endl;
	delete TheModule;

	return 0;
}
